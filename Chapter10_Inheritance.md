# 第 10 章：类的继承（OOP 第二大特性）

## 继承的定义

将类型的操作分离开，把一些最基础的操作单独用**基类型**（Base）表示，而所有类型都从该类型**派生**（Derive）

## 基类型、派生类型的概念

* 基类型（父类型、超类型）：只包含一些基本操作元素的类型
* 派生类型（子类型）：从基类型拓展出来的新类型

## 继承想表达的含义

is a 模型，如果 `Student` 类型从 `Person` 类型派生，则从生态角度理解为 `Student is a Person`；不要乱用继承关系，否则会出现 `Son is a Father` 的类似无厘头理解

## 继承关系

可以形成链条达到很多层，不一定只能是一层

## 派生书写格式

`类定义 : 基类型名`

## `object` 是所有类型的最终基类

1. 所有类型都从 `object` 派生
2. `object.ReferenceEquals`
3. `object` 自带的 `operator ==` 和 `operator !=`
4. `GetHashCode`
5. `ToString`
6. `Equals`：只是简单调用了一下 `ReferenceEquals`

## 基类型和派生类型的互相转换

基类型转派生类型（大转小）用强制转换；派生类型转基类型（小转大）用隐式转换；转换错误会产生异常

## 在派生类型里使用基类型的成员（赋值、取值、调用等）

`base.成员`

## `protected` 访问修饰符

* 概念：只能用于当前类和其派生下去的所有类里
* `protected` 修饰符：只能用于派生关系
* `protected internal` 修饰符：融合 `protected` 和 `internal` 两大修饰：在项目内随便用，或者对外只能在当前派生关系里可用

## 继承的模型

单继承，C# 不允许多继承，因为自然世界没有一个人有多个爸爸的说法

## 密封类

`sealed` 关键字：该类不可继续派生子类型

## 基类型成员信息的重写

1. `virtual` 修饰符：表示方法可以被子类型重写，然后子类型就是新的执行逻辑了；
2. `base` 关键字可调用基类型的执行行为（甚至是构造器）
3. `override` 修饰符：重写基类型的成员；重写所有方法时都需要加此关键字来保证方法是用来重写的，而不是拿来隐藏的（隐藏请参见下面 `new` 修饰符）
4. 可重写的成员类型：属性、方法
5. `new` 修饰符：隐藏基类型的该成员，表示该方法在这个类里应是这样的（你可以认为是两个成员的执行思维和逻辑毫无关联，但只是恰好有了一个完全一样的名字，有时候也可以理解为故意不想要基类型的该同名成员）
6. `sealed` 方法修饰符：修饰方法不可被派生类重写

## **抽象类**（Abstract Class）

1. `abstract` 关键字介绍
2. 定义抽象类：`[访问修饰符] abstract class 类型名`
3. 抽象成员和类必须在继承后立刻实现
4. 多态的用法（OOP 第三大特性）
    举例：`Shape` 抽象类里实现 `Triangle`、`Circle` 之类的类型，然后实现抽象类给出的 `Area` 只读属性；最后从 `Main` 方法里直接通过 `Shape s = new Triangle()` 的模式实例化后，调用 `s` 的 `Area` 属性获取面积数值；同时 `s` 因为是 `Shape` 类型的，所以 `Triangle` 类型特有的成员可能会看不到，此时就需要强制转换了
5. 抽象类之间的相互继承，但抽象类不能派生自实例类
6. 可以抽象 `object` 的自带方法来让派生类型实现，例如 `abstract override ToString()`
7. 可以在抽象类里写一些已经有执行逻辑的方法，且这些方法可以标记 `sealed` 以防止派生下去的时候又修改（重写）掉执行逻辑
8. 注意抽象类里实例在子类重写后，是怎么用的；特别是抽象属性：抽象属性是以属性一个整体作为抽象的，所以不能单独抽象里面的其中一种方法，比如说让 `get` 抽象，`set` 不抽象（或者反过来）

## `is` 和 `as`

* `is` 关键字对类型进行判断和验证
* `as` 关键字对类型进行判断和转换

## 自定义异常简介

自定义异常类型，继承 `System.Exception`，然后就可以用 `throw` 来抛出你自己定义的异常了