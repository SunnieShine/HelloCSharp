# 第 10 章：类的继承（OOP 第二大特性）

1. 继承的定义：将类型的操作分离开，把一些最基础的操作单独用**基类型**（Base）表示，而所有类型都从该类型**派生**（Derive）
2. 基类型（父类型、超类型）：只包含一些基本操作元素的类型
3. 派生类型（子类型）：从基类型拓展出来的新类型
4. 继承想表达的含义：is a 模型，如果 `Student` 类型从 `Person` 类型派生，则从生态角度理解为 `Student is a Person`；不要乱用继承关系，否则会出现 `Son is a Father` 的类似无厘头理解
5. 继承关系可以形成链条达到很多层，不一定只能是一层
6. 派生书写格式：`类定义 : 基类型名`
7. 所有类型都从 `object` 派生，`object` 是所有类型的最终基类
    1. `object.ReferenceEquals`
    2. `object` 自带的 `operator ==` 和 `operator !=`
    3. `GetHashCode`
    4. `ToString`
    5. `Equals`：只是简单调用了一下 `ReferenceEquals`
8. 基类型和派生类型的互相转换：基类型转派生类型（大转小）用强制转换；派生类型转基类型（小转大）用隐式转换；转换错误会产生异常
9. 在派生类型里使用基类型的成员（赋值、取值、调用等）
10. `protected` 访问修饰符级别：只能用于当前类和其派生下去的所有类里
    * `protected` 修饰符：只能用于派生关系
    * `protected internal` 修饰符：融合 `protected` 和 `internal` 两大修饰：在项目内随便用，或者对外只能在当前派生关系里可用
11. 继承的模型：单继承，C# 不允许多继承，因为自然世界没有一个人有多个爸爸的说法
12. 密封类：`sealed` 关键字：该类不可继续派生子类型
13. 基类型成员信息的重写
    1. `virtual` 修饰符：表示方法可以被子类型重写，然后子类型就是新的执行逻辑了；
    2. `base` 关键字可调用基类型的执行行为（甚至是构造器）
    3. `override` 修饰符：重写基类型的成员；重写所有方法时都需要加此关键字来保证方法是用来重写的，而不是拿来隐藏的（隐藏请参见下面 `new` 修饰符）
    4. 可重写的成员类型：属性、方法
    5. `new` 修饰符：隐藏基类型的该成员，表示该方法在这个类里应是这样的（你可以认为是两个成员的执行思维和逻辑毫无关联，但只是恰好有了一个完全一样的名字，有时候也可以理解为故意不想要基类型的该同名成员）
    6. `sealed` 方法修饰符：修饰方法不可被派生类重写
14. **抽象类**（Abstract Class）
    1. `abstract` 关键字介绍
    2. 定义抽象类：`[访问修饰符] abstract class 类型名`
    3. 抽象成员和类必须在继承后立刻实现
    4. 多态的用法（OOP 第三大特性）
        举例：`Shape` 抽象类里实现 `Triangle`、`Circle` 之类的类型，然后实现抽象类给出的 `Area` 只读属性；最后从 `Main` 方法里直接通过 `Shape s = new Triangle()` 的模式实例化后，调用 `s` 的 `Area` 属性获取面积数值；同时 `s` 因为是 `Shape` 类型的，所以 `Triangle` 类型特有的成员可能会看不到，此时就需要强制转换了
    5. 抽象类之间的相互继承，但抽象类不能派生自实例类
    6. 可以抽象 `object` 的自带方法来让派生类型实现，例如 `abstract override ToString()`
    7. 可以在抽象类里写一些已经有执行逻辑的方法，且这些方法可以标记 `sealed` 以防止派生下去的时候又修改（重写）掉执行逻辑
15. `is` 关键字对类型进行判断和验证
16. `as` 关键字对类型进行判断和转换
17. 综合内容：自定义异常类型，继承 `System.Exception`，然后就可以用 `throw` 来抛出你自己定义的异常了