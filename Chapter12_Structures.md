# 第 12 章：值类型和自定义结构

1. **栈内存**（Stack Memory）和**栈帧**（Stack Frame）的概念

2. 值类型的诞生原因：为了加快传参速度；所以值类型一般都很小，尽量不把大的类型定义为结构（一般是 64 字节）；大多数内置类型都是值类型，除了 `string` 和 `object` 是引用类型

3. 值类型传参是复制内容；包含指针则只复制地址数值以表达两个成员指向同一个内存块；引用类型始终拷贝的是引用

4. 结构的定义和使用：`[访问修饰符] struct 结构名`

5. 结构和类的区别：
    1. 实例化需要把全部字段都实例化；引用类型则只初始化必要的，其他的都默认初始化为可以用 0 表达的类型；
    2. 结构必须在构造器里实例化所有成员；引用类型并非如此
    3. 结构的无参构造器随时都可以用；引用类型构造器只在你不写任何自定义构造器的情况下会自动生成
    4. 实例化结构对象，如果是在方法里，那么就是放在栈内存里的，它会在临时存储区创建对象，然后以默认行为初始化成员，最后调用构造器赋值；而引用类型则不用，直接创建在堆内存上；当然，值类型也可以放在堆内存里，不过需要引用类型的帮助，或者是某个结构里的字段。如果是全局字段还是放栈内存里的话，那么放在哪个栈帧上呢？

6. 值类型的复制构造器：值类型的复制构造函数可以直接使用 `this` 关键字来接收赋值信息，因为值类型是复制副本，因此完全可以直接通过赋值运算符把数值给过去

    ```csharp
    public struct Student
    {
        private int _age;
        private bool _isBoy;
        private string _name;
    
        public Student(Student another)
        {
            // Assign directly.
            this = another;
        }
    }
    ```

7. 值类型和引用类型的存储区转换：**装箱**（Boxing）和**拆箱**（Unboxing）：
    1. 装箱：`object i = 3;`，即值类型赋值给引用类型时，就会把数值包装起来，放在堆内存里，以地址形式表达；
    2. 拆箱：`int i = (int)o;`，即引用类型转回值类型时，就会把数据信息提取出来，放回栈内存
    3. `object.ReferenceEquals` 对值类型处理结果总为 `false`，因为需要装箱，随后导致地址一定不相同
    4. 装箱和拆箱很耗性能，请尽量不要发生此类行为
    5. 拆箱类型错误会引起运行时异常（类似于前面强制转换错误时产生异常）

8. 值类型不可继承任何类，但能实现接口；值类型不能派生自别的值类型，默认派生自 `System.ValueType`（而它又派生自 `System.Object`，它们都是引用类型）；在自定义值类型时，为了不影响执行效率和性能，请把默认实现的所有方法都重写掉

9. 请不要相信结构的赋值运算符——只读的结构字段真的是只读的：

    ```csharp
    using System;
    
    internal struct Mutable
    {
        private int x;
        
        public int Mutate()
        {
            x++;
            return x;
        }
    }
    
    internal class Test
    {
        public readonly Mutable m = new Mutable();
        
        private static void Main()
        {
            Test t = new Test();
            
            Console.WriteLine(t.m.Mutate());
            Console.WriteLine(t.m.Mutate());
            Console.WriteLine(t.m.Mutate());
        }
    }
    ```

    在这一则实例里，输出结果应该是三个 1。这是因为 `m` 是 `readonly` 的，在我们下方修改它的时候，系统会对这样的情况作出识别，当我们确实会修改内部的字段的时候，会自动产生一个保护性副本。而最终输出和修改的内容实际上是这个副本的东西，而不是原本的数据。这也就导致了结果得到的是 1（从 0 变为 1）；至于为什么三个都是相同的 1，是因为每执行一次都会产生 `x` 字段的变化，所以每次执行输出的时候，这里的 `t.m` 都会产生一次副本。所以实际上三个 `t.m` 是四个不同的对象。那么问题来了，为什么说四个不同的对象，而不是三个呢？因为这变动的 `t.m` 都是保护性副本，一共复制了三次，而算上 `m` 自己，一共是 4 个。
    另外，从这个角度来说，引用类型的 `readonly` 不会产生类似的功效：引用类型复制的是引用，说白了就是地址，所以两个变量本身只是指向同一块内存而已。