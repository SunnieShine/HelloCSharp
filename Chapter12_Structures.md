# 第 12 章：值类型和自定义结构

## **栈内存**（Stack Memory）、**栈帧**（Stack Frame）

### 栈内存

函数的每一个调用和退出返回上一级函数的过程，将函数内部执行所需变量分配到栈内存里

### 栈帧

栈内存里每一个函数固定分配内存的一个单位，一个函数调用，包含变量分配的内存等等，这些整体作为一个栈帧

## 值类型的诞生原因

为了加快传参速度；所以值类型一般都很小，尽量不把大的类型定义为结构（一般是 64 字节）；大多数内置类型都是值类型，除了 `string` 和 `object` 是引用类型

## 复制区别

* 值类型传参是复制内容
* 包含指针则只复制地址数值以表达两个成员指向同一个内存块；引用类型始终拷贝的是引用

## 结构的定义和使用

`[访问修饰符] struct 结构名`

## 结构和类的区别

1. 实例化需要把全部字段都实例化；引用类型则只初始化必要的，其他的都默认初始化为可以用 0 表达的类型；
2. 结构必须在构造器里实例化所有成员；引用类型并非如此
3. 结构的无参构造器随时都可以用；引用类型构造器只在你不写任何自定义构造器的情况下会自动生成
4. 实例化结构对象，如果是在方法里，那么就是放在栈内存里的，它会在临时存储区创建对象，然后以默认行为初始化成员，最后调用构造器赋值；而引用类型则不用，直接创建在堆内存上；当然，值类型也可以放在堆内存里，不过需要引用类型的帮助，或者是某个结构里的字段。如果是全局字段还是放栈内存里的话，那么放在哪个栈帧上呢？

## 值类型的复制构造器

值类型的复制构造函数可以直接使用 `this` 关键字来接收赋值信息，因为值类型是复制副本，因此完全可以直接通过赋值运算符把数值给过去

```csharp
public struct Student
{
    private int _age;
    private bool _isBoy;
    private string _name;

    public Student(Student another)
    {
        // Assign directly.
        this = another;
    }
}
```

## 静态属性、静态字段里，结构和类的使用区别

在类里，我们允许属性和字段使用静态的，这样做可以节省内存，也可以区分对象使用的方式。不过，在静态属性和静态字段里，结构和类里会有区别。由于结构对象永远是复制副本，所以静态属性和静态字段一旦被定义，它们应该没有可见的区别：

```csharp
public static readonly Structure S = new Structure();

public static Structure S
{
    get
    {
        return new Structure();
    }
}
```

从这个例子里，我们可以看到，显然定义成静态字段的形式，和定义为静态属性的形式，是没有区别的；但在类里，由于复制引用的关系，如果你尝试去修改引用类型里面的成员，`static readonly` 字段和 `static` 属性就有区别了：引用类型（类）是可能导致数据产生改变的，但值类型不会，因为值类型本身就是复制副本的，所以你怎么改也只会改到副本上的数据，而原始数据并不会发生变动

## 值类型和引用类型的存储区转换

* **装箱**（Boxing）和**拆箱**（Unboxing）的概念
  * 装箱：`object i = 3;`，即值类型赋值给引用类型时，就会把数值包装起来，放在堆内存里，以地址形式表达
  * 拆箱：`int i = (int)o;`，即引用类型转回值类型时，就会把数据信息提取出来，放回栈内存
* `object.ReferenceEquals` 对值类型处理结果总为 `false`，因为需要装箱，随后导致地址一定不相同
* 装箱和拆箱很耗性能，请**尽量不要**发生此类行为
* 拆箱类型错误会引起运行时异常（类似于前面强制转换错误时产生异常）

## 继承区别

* 值类型不可继承任何类，但能实现接口
* 值类型不能派生自别的值类型，默认派生自 `System.ValueType`（而它又派生自 `System.Object`，它们都是引用类型）
* 在自定义值类型时，为了不影响执行效率和性能，请把默认实现的所有方法都重写掉

## 请不要相信结构的赋值运算符

只读的结构字段真的是只读的（这一点和引用类型有区别）

```csharp
using System;

internal struct Mutable
{
    private int x;
    
    public int Mutate()
    {
        x++;
        return x;
    }
}

internal class Test
{
    public readonly Mutable m = new Mutable();
    
    private static void Main()
    {
        Test t = new Test();
        
        Console.WriteLine(t.m.Mutate());
        Console.WriteLine(t.m.Mutate());
        Console.WriteLine(t.m.Mutate());
    }
}
```

在这一则实例里，输出结果应该是三个 1。这是因为 `m` 是 `readonly` 的，在我们下方修改它的时候，系统会对这样的情况作出识别，当我们确实会修改内部的字段的时候，会自动产生一个保护性副本。而最终输出和修改的内容实际上是这个副本的东西，而不是原本的数据。这也就导致了结果得到的是 1（从 0 变为 1）；至于为什么三个都是相同的 1，是因为每执行一次都会产生 `x` 字段的变化，所以每次执行输出的时候，这里的 `t.m` 都会产生一次副本。所以实际上三个 `t.m` 是四个不同的对象。那么问题来了，为什么说四个不同的对象，而不是三个呢？因为这变动的 `t.m` 都是保护性副本，一共复制了三次，而算上 `m` 自己，一共是 4 个。

另外，从这个角度来说，引用类型的 `readonly` 不会产生类似的功效：引用类型复制的是引用，说白了就是地址，所以两个变量本身只是指向同一块内存而已。

