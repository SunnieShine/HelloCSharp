# 第 12 章：值类型和自定义结构

1. **栈内存**（Stack Memory）和**栈帧**（Stack Frame）的概念

2. 值类型的诞生原因：为了加快传参速度；所以值类型一般都很小，尽量不把大的类型定义为结构（一般是 64 字节）；大多数内置类型都是值类型，除了 `string` 和 `object` 是引用类型

3. 值类型传参是复制内容；包含指针则只复制地址数值以表达两个成员指向同一个内存块；引用类型始终拷贝的是引用

4. 结构的定义和使用：`[访问修饰符] struct 结构名`

5. 结构和类的区别：
    1. 实例化需要把全部字段都实例化；引用类型则只初始化必要的，其他的都默认初始化为可以用 0 表达的类型；
    2. 结构必须在构造器里实例化所有成员；引用类型并非如此
    3. 结构的无参构造器随时都可以用；引用类型构造器只在你不写任何自定义构造器的情况下会自动生成
    4. 实例化结构对象，如果是在方法里，那么就是放在栈内存里的，它会在临时存储区创建对象，然后以默认行为初始化成员，最后调用构造器赋值；而引用类型则不用，直接创建在堆内存上；当然，值类型也可以放在堆内存里，不过需要引用类型的帮助，或者是某个结构里的字段。如果是全局字段还是放栈内存里的话，那么放在哪个栈帧上呢？

6. 值类型的复制构造器：值类型的复制构造函数可以直接使用 `this` 关键字来接收赋值信息，因为值类型是复制副本，因此完全可以直接通过赋值运算符把数值给过去

    ```csharp
    public struct Student
    {
        private int _age;
        private bool _isBoy;
        private string _name;
    
        public Student(Student another)
        {
            // Assign directly.
            this = another;
        }
    }
    ```

7. 值类型和引用类型的存储区转换：**装箱**（Boxing）和**拆箱**（Unboxing）：
    1. 装箱：`object i = 3;`，即值类型赋值给引用类型时，就会把数值包装起来，放在堆内存里，以地址形式表达；
    2. 拆箱：`int i = (int)o;`，即引用类型转回值类型时，就会把数据信息提取出来，放回栈内存
    3. `object.ReferenceEquals` 对值类型处理结果总为 `false`，因为需要装箱，随后导致地址一定不相同
    4. 装箱和拆箱很耗性能，请尽量不要发生此类行为
    5. 拆箱类型错误会引起运行时异常（类似于前面强制转换错误时产生异常）

8. 值类型不可继承任何类，但能实现接口；值类型不能派生自别的值类型，默认派生自 `System.ValueType`（而它又派生自 `System.Object`，它们都是引用类型）；在自定义值类型时，为了不影响执行效率和性能，请把默认实现的所有方法都重写掉