# C# 4

## 动态绑定

允许使用 `dynamic` 关键字表达一个数据类型，该类型可以使用任何写法，来代替一个对象的执行，具体这个写法对不对取决于运行时检查对象是不是这个类型，有没有这个调用方式
1. 使用 `dynamic` 关键字
2. 创建一个可支持任意属性调用的对象（使用 `DynamicObject` 类的继承来完成）

扩展方法上如果使用 `dynamic` 对象的话，一定要注意 C# 会阻断识别数据类型，因此无法继续推断后续的调用内容，因此，此时需要强制转换：

```csharp
class C
{
}

static class E
{
    public static C WithString(this C @this, string s)
    {
        return @this;
    }
}
```

调用：

```csharp
dynamic d = "test";

// Wrong.
var c = new C().WithString(d).WithString(d);
```

你必须指定参数的类型。

```csharp
dynamic d = "test";

// Correct.
var c = new C().WithString((string)d).WithString((string)d);
```

## **可选参数**（Optional Parameters）和**命名参数**（Named Parameters）

允许把参数名写在参数上保证函数调用模式

## **协变性**（Covariance）和**逆变性**（Contravariance）

概念：标记 `in` 和 `out` 到泛型委托和泛型接口上，以表示泛型参数支持协变性和逆变性

协变性和逆变性的概念：就引用类型而言，可以自动通过某一个类型转换为它的基类型的过程，叫做对象的协变；反之，通过基类型转换自具体类型的时候，叫做对象的逆变。协变性和逆变性和普通的显式转换、隐式转换不一样，因为这两个概念仅针对一个引用类型而言。

### 数组的协变性

数组在最开始就拥有协变的概念，即把一个数组类型隐式变为另外一个数组类型，例如

```csharp
object[] o = new string[] { "Hello", ",", "world", "!" };
```

最开始，C# 就允许这么进行赋值。不过这样的赋值，由于最初的类型是字符串的数组，所以你无法对这个 `o` 变量赋别的类型数值进去，否则百分之百是会产生 `ArrayTypeDismatchException` 的异常信息。

> 其实说到这里我还是比较遗憾的。很多 C#er，甚至官方人士都说，这个数组协变是一个坑人的概念，因为它转过去是成功的，但这只允许读取，但写入和修改数据本应该是允许的，但实际上并不允许；而且这个写入的报错并不是编译行为，而是运行时行为，这一点确实很遗憾。

### 泛型的协变性

先考虑一下，为什么泛型是不变的：

考虑一个 List 集合，集合里存储的是一个个 Student 的信息。假如 C# 允许协变，那么我们就可以允许 `List<Person> list = new List<Student> { ZhangSan, ... }` 这样的行为成功执行。可以看到 list 本身是存储 `Person` 作为成员的列表，右侧的集合的每一个元素本也都是 `Student` 类型。如果 `Student` 从 `Person` 类派生，显然这个行为就没啥大问题。不过，由于 `list` 的元素类型是 `Person`，所以我并不清楚里面具体可以存储什么子类型，可以是 `Student`，可以是 `Teacher`，甚至还可以是别的，比如 `Policeman` 之类的。右侧的类型传给左侧赋值是成功的，但原本的列表还是 `Student` 作为元素类型的，如果我给这个 `list` 添加别的类型，不就卡了语义的 bug 了吗？

所以，泛型是不变的，就是因为我并不知道泛型到底存储的是什么元素，贸然修改添加数据就可能使得类型不一致（本来要求 `Student`，但因为 `list` 的元素给的是 `Person`，就好像我可以传入 `Teacher` 或者别的什么一样）。

泛型的隐藏特效——协变和逆变：

1. 逆变性：如果泛型参数只用来当内部成员的参数，那么这表示这个数据只用于传入。传入就意味着数据本身应该是具体化的类型，如果是一个抽象类的话，作为参数显然依旧会被转换为具体类型才能参与程序的运行，要知道抽象类只是一个模板，它不能实例化。所以，既然参数会从抽象转具体（大转小），那么这不就符合逆变的基本思路吗？因此，当泛型参数仅用于传参的时候，我们可以认为它是可以逆变的

2. 协变性：如果泛型参数只用来当返回值，那么这就表示这个泛型只从内往外输出。只要数据不发生修改，那么类似前文所说的列表集合的直接转换就应当奏效。这正好就对应了数据的协变性的要求，因此泛型只用来作为返回值时，可以认为它是可以协变的